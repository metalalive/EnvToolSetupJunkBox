#### TLS 1.3 header
The  Header message below sent from FireFox web browser to embedded server running on STM32F4xx board, connected with ESP8266 wifi module.

```
(gdb) print * espGlobal.dev.ipd.pbuf_head 
$52 = {next = 0x20005b90, payload_len = 225, ip = {ip = "L\004\000\240"}, port = 214, ref = 0, chain_len = 3 '\003',

(gdb) print * espGlobal.dev.ipd.pbuf_head->next 
$53 = {next = 0x20005930, payload_len = 256, ip = {ip = "2:00"}, port = 12346, ref = 0, chain_len = 75 'K', payload = 0x20005bac ""}

(gdb) print * espGlobal.dev.ipd.pbuf_head->next->next 
$55 = {next = 0x0, payload_len = 36, ip = {ip = "\000\000\000"}, port = 0, ref = 0, chain_len = 0 '\000', payload = 0x2000594c ""}

```

```
(gdb) print /x *(uint8_t [128] *)(espGlobal.dev.ipd.pbuf_head->payload + 0)
$57 = {0x16, 0x3, 0x1, 0x2, 0x0, 0x1, 0x0, 0x1, 0xfc, 0x3, 0x3, 0x50, 0xbd, 0x28, 0x85, 0x26, 0xfb, 0x83, 0x46, 0x1c,    0x30, 0xb2, 0x82, 0x77, 0x34, 0x69, 0x9b, 0x9d, 0x6f, 0xaa, 0x8, 0xd1, 0x60, 0x2c, 0x21, 0xde, 0xaf, 0xed, 0x3b, 0xdc, 0xe9, 0x70, 0xba, 0x20, 0xaa, 0x67, 0x8f, 0x14, 0x3a, 0x35, 0xb8, 0xfe, 0x1a, 0x4a, 0xfc, 0x7e, 0xf5, 0x29, 0x92, 0x2d, 0xca, 0x39, 0xe3, 0xeb, 0xbc, 0x1c, 0x48, 0x69, 0x47, 0xf6, 0xe3, 0x1e, 0xfa, 0xe3, 0x53, 0xd, 0x0, 0x24, 0x13, 0x1, 0x13, 0x3, 0x13, 0x2, 0xc0, 0x2b, 0xc0, 0x2f, 0xcc, 0xa9, 0xcc, 0xa8, 0xc0, 0x2c, 0xc0, 0x30, 0xc0, 0xa, 0xc0, 0x9, 0xc0, 0x13, 0xc0, 0x14, 0x0, 0x33, 0x0, 0x39, 0x0, 0x2f, 0x0, 0x35, 0x0, 0xa, 0x1, 0x0, 0x1, 0x8f, 0x0, 0x17, 0x0, 0x0, 0xff, 0x1, 0x0, 0x1, 0x0, 0x0}
  ```
| Byte(s) | meaning |
|---------|---------|
| `0x16,`           | handshake record |
| `0x3, 0x1,`       |  protocol version 3.1 |
| `0x2,  0x0,`      |  0x200 bytes (512 bytes) of handshake message (excluding these 2 bytes) |
| `0x1, `           | handshank message type, means client-hello|
| `0x0, 0x1, 0xfc,` | (0x1fc) bytes of client-hello data|
| `0x3, 0x3,`       | client version, means TLS v1.2, these fields are no longer used for version negotiation & hardcoded to version 1.2 .|
| `0x50, 0xbd, ... 0x70, 0xba,` | 32-byte client random data used in later session |
| `0x20`                        | number of bytes that represents session ID (32 bytes in this case) |
| `0xaa, 0x67, ... 0x53, 0xd,`  | session ID |
| `0x00, 0x24, `  | number of bytes that represents Cipher Suite (36 bytes in this case) |
| `0x13, 0x1,`    | Cipher Suite #1 : TLS_AES_128_GCM_SHA256 (each time we take 2 bytes)  |
| `0x13, 0x3,`    | Cipher Suite #2 : TLS_CHACHA20_POLY1305_SHA256  |
| `0x13, 0x2,`    | Cipher Suite #3 : TLS_AES_256_GCM_SHA384 |
| `0xc0, 0x2b,`   | Cipher Suite #4 :  TLS v1.3 cannot use subsequent CipherSuite defined in lower version of TLS protocol (e.g. TLS v1.2 , TLS v1.1 ...etc.) , as specifiction defined [at here](https://tools.ietf.org/html/rfc8446#appendix-B.4) |
| `0x0,  0xa,`    | Cipher Suite #18: similarly, cannot be used in TLS v1.3 |
| `0x1, 0x0`   | compression method, no longer used in TLS v1.3 |
| `0x1, 0x8f,` | number of bytes (0x18f bytes in this case) used in extension parts |
| `0x1, 0x17,` | unknown extension type ?? |
  
  
```
(gdb) print /x *(uint8_t [97] *)(espGlobal.dev.ipd.pbuf_head->payload + 128)
$58 = {0xa, 0x0, 0xe, 0x0, 0xc, 0x0, 0x1d, 0x0, 0x17, 0x0, 0x18, 0x0, 0x19, 0x1, 0x0, 0x1, 0x1, 0x0, 0xb, 0x0, 0x2, 0x1, 0x0, 0x0, 0x23, 0x0, 0x0, 0x0, 0x10, 0x0, 0xe, 0x0, 0xc, 0x2, 0x68, 0x32, 0x8, 0x68, 0x74, 0x74, 0x70, 0x2f, 0x31, 0x2e, 0x31, 0x0, 0x5, 0x0, 0x5, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x33, 0x0, 0x6b, 0x0, 0x69, 0x0, 0x1d, 0x0, 0x20, 0xb8, 0x62, 0x1, 0xe2, 0x4b, 0x4f, 0x4c, 0x16, 0x49, 0xf, 0x92, 0xa9, 0xb2, 0xa, 0x2b, 0x4c, 0x8c, 0x5f, 0x8b, 0xad, 0xc6, 0xfb, 0xa3, 0x2b, 0xc9, 0x4e, 0x90, 0x89, 0x16, 0x6b, 0xe, 0x7e, 0x30}
```
| Byte(s) | meaning |
|---------|---------|
| `0x0, 0xa,`       | exception type: Supported Groups |
| `0x0, 0xe,`       | number of bytes that follows ( 0xe = 14 bytes, in this case) |
| `0x0, 0xc,`       | number of bytes that follows ( 0xe = 12 bytes, in this case) |
| `0x0, 0x1d,`      | assigned value for the curve **x25519** |
| `0x0, 0x17,`      | assigned value for the curve **secp256r1**  |
| `0x0, 0x18,`      | assigned value for the curve **secp384r1** |
| `0x0, 0x19,`      | ??? |
| `0x1, 0x0,`       | ??? |
| `0x1, 0x1,`       | ??? |

| Byte(s) | meaning |
|---------|---------|
| `0x0, 0xb,`       | exception type: unknown ?? not defined in spec. |




```
(gdb) print /x *(uint8_t [128] *)(espGlobal.dev.ipd.pbuf_head->next->payload + 0)
$59 = {0x0, 0x17, 0x0, 0x41, 0x4, 0xda, 0xb9, 0x67, 0x61, 0x8e, 0x6f, 0x49, 0xe3, 0x4a, 0xec, 0xd4, 0x6a, 0x6d, 0x77, 0x6b, 0x69, 0x79, 0x45, 0x44, 0x2b, 0x6a, 0xcd, 0xc2, 0xa3, 0x10, 0xc8, 0xeb, 0xcc, 0xf2, 0xe, 0x91, 0x97, 0xf, 0x6b, 0x86, 0xd0, 0x36, 0x52, 0xc6, 0x8c, 0xa4, 0x0, 0xb7, 0xe3, 0x9a, 0x48, 0x32, 0x6f, 0x61, 0xf4, 0x73, 0x71, 0x31, 0xd7, 0xaa, 0xda, 0xd5, 0xaa, 0x39, 0xde, 0xf4, 0x1b, 0x55, 0x29, 0x0, 0x2b, 0x0, 0x9, 0x8, 0x3, 0x4, 0x3, 0x3, 0x3, 0x2, 0x3, 0x1, 0x0, 0xd, 0x0, 0x18, 0x0, 0x16, 0x4, 0x3, 0x5, 0x3, 0x6, 0x3, 0x8, 0x4, 0x8, 0x5, 0x8, 0x6, 0x4, 0x1, 0x5, 0x1, 0x6, 0x1, 0x2, 0x3, 0x2, 0x1, 0x0, 0x2d, 0x0, 0x2, 0x1, 0x1, 0x0, 0x1c, 0x0, 0x2, 0x40, 0x1, 0x0, 0x15, 0x0, 0xa7, 0x0, 0x0}
```

ignore subsequent zero-padding bytes
```
(gdb) print /x *(uint8_t [128] *)(espGlobal.dev.ipd.pbuf_head->next->payload + 128)
$60 = {0x0 <repeats 128 times>}

(gdb) print /x *(uint8_t [36] *)(espGlobal.dev.ipd.pbuf_head->next->next->payload + 0)
$61 = {0x0 <repeats 36 times>}

```



#### Reference
* [RFC 8446 - The Transport Layer Security (TLS) Protocol Version 1.3](https://tools.ietf.org/html/rfc8446)

* [TLS 1.3 handshaking example : Every byte explained and reproduced](https://tls13.ulfheim.net/)

* [Traffic analysis of SSL/TLS session](http://blog.fourthbit.com/2014/12/23/traffic-analysis-of-an-ssl-slash-tls-session)

